
- builder
- builder with change tracking for update based on previous value
  - compares old prop value marks change if different
- builder with change tracking without previous value 
  - update always marks change

watch changes, save lastmod,size,checksum (check checksum if lastmod changes)

JSON backed change tracking from intefrace,
DTO can be just an interface, no need for concrete class

data interfaces are just views into a datastore or even key-value store (if value is object)
 - Spring data projections, are something in this direction

Entity only defines id field
 - no monkey business, must be called id
 - no frikin java beans, let's look more like records (getId()->id(), getName()->name())

```java
interface Entity<T>{
  T id();
}

interface Auditable{
  boolean deleted();
  Long modifyBy();
  Instant modifyTs();
  Long createBy();
  Instant createTs();
}

interface BookEntity extends Entity<ObjectId>{
    String title();
}
interface BookAuditable extends Book, Auditable{}
interface BookEntityFull extends BookEntity, BookAuditable{}

interface UserEntity extends Entity<Long>{}
interface UserAuditable extends User, Auditable{}

interface User extends UserEntity{
    String name();
}

enum BookEnum{id, deleted, modifyBy, modifyTs, createBy, createTs, title}
enum UserEnum{id, deleted, modifyBy, modifyTs, createBy, createTs, name}

// autogenerated, on demand
record BookAuditableRec (Long id, boolean deleted, Long modifyBy, Instant modifyTs, Long createBy, Instant createTs) implements BookAuditable{}
class BookAuditableBuild{// autogenerated
  Long id;
  boolean deleted;
  Long modifyBy;
  Instant modifyTs;
  Long createBy;
  Instant createTs;
}

```

# records inline builder 

In age of agents and devs letting agents code stuff. It is time to integrate some old-school concepts in similar intrusive fashion. (chance is sbdy did this, still ...)

Instead of annotation processor strictly generating classes somewhere else or even worse lombok generating bytecode directly (how do hell I know what it did, and requires special IDE integrations all over the place).

I know there are already libs doing a thing like this (builders for records)..

So, lets imagine you write a record:

```java
@MakeBuilder
record Book(Long id, String title){}
```

and you get somewhere in generated classes:
```java
public class BookBuilder(){
  Long id;
  String title;
  public BookBuilder id(Long id){this.id=id; return this;}
  public BookBuilder title(String title){this.title=title; return this;}
  public Book build(){return new Book(id,title);}
}
```

would it be nicer, when you save and update the record it is done simply inline as soon as you save

```java
@MakeBuilder
record Book(Long id, String title){

  @Generated
  public static class Builder(){
    Long id;
    String title;
    public BookBuilder id(Long id){this.id=id; return this;}
    public BookBuilder title(String title){this.title=title; return this;}
    public Book build(){return new Book(id,title);}
  }
}
```

Not every augmentation, code generation fits inline, but personally I can see more than few cases whare I would prefer it this way,
as it also removes some limitations on what you can do.
